/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => RubikCubeAlgos
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/RubikCoordinates.ts
var DEFAULT = {
  WIDTH: 3,
  /* default rubik cube width */
  HEIGHT: 3,
  /* default rubik cube height */
  CUBE_COLOR: "#ff0",
  /* yellow for cube */
  ARROW_COLOR: "#08f"
  /* sky blue for arrows */
};
var PLL = class {
  constructor() {
    this.COORDINATES = new Array();
    this.width = DEFAULT.WIDTH;
    this.height = DEFAULT.HEIGHT;
    this.cubeColor = DEFAULT.CUBE_COLOR;
    this.arrowColor = DEFAULT.ARROW_COLOR;
    this.arrows = "";
    this.codeBlockInterpretationSuccessful = true;
  }
  setDimension(w, h) {
    this.width = w;
    this.height = h;
  }
  setCubeColor(s) {
    this.cubeColor = "#" + s;
  }
  setArrowColor(s) {
    this.arrowColor = "#" + s;
  }
  setArrows(s) {
    this.arrows = s;
  }
  toString() {
    return "pll[cubeClr'" + this.cubeColor + "',arrowColor'" + this.arrowColor + "',arrows'" + this.arrows + "']";
  }
  interpretCodeBlock(rows) {
    if (rows.length === 0) {
      return this.fuckThisShitUp("[no input]", "at least 1 parameter needed: 'dimension/cubeColor/arrowColor/arrows'");
    }
    for (let r = 0; r < rows.length; r++) {
      let row = rows[r];
      if (row.match("dimension:\\d+,\\d+( //.*)?")) {
        let wXh = row.split(" ")[0].trim().replace("dimension:", "");
        let wXhSplit = wXh.split(",");
        let w = wXhSplit[0];
        let h = wXhSplit[1];
        if (w < 2 || h < 2 || w > 10 || h > 10) {
          return this.fuckThisShitUp(row, "invalid dimensions - expected: 2 < width/height < 10");
        }
        this.setDimension(w, h);
      } else if (row.match("cubeColor:([a-f0-9]{3}){1,2}( //.*)?")) {
        let newCubClr = row.split(" ")[0].trim().replace("cubeColor:", "");
        this.setCubeColor(newCubClr);
      } else if (row.match("arrowColor:([a-f0-9]{3}){1,2}( //.*)?")) {
        let newAroClr = row.split(" ")[0].trim().replace("arrowColor:", "");
        this.setArrowColor(newAroClr);
      } else if (row.match("arrows:\\d+(\\.\\d+)?(-|\\+)\\d+(\\.\\d+)?(,\\d+(\\.\\d+)?(-|\\+)\\d+(\\.\\d+)?)*( //.*)?")) {
        let newArrows = row.split(" ")[0].trim().replace("arrows:", "");
        this.setArrows(newArrows);
      } else {
        return this.fuckThisShitUp(row);
      }
    }
    this.calculateCoordinates();
  }
  calculateCoordinates() {
    this.COORDINATES[0] = [];
    let index = 1;
    for (let h = 0; h < this.height; h++) {
      for (let w = 0; w < this.width; w++) {
        this.COORDINATES[index++] = [w * 100 + 50, h * 100 + 50];
      }
    }
  }
  fuckThisShitUp(mandatoryLastLineNotInterpretable, optionalReasonForFailure) {
    this.codeBlockInterpretationSuccessful = false;
    this.lastNonInterpretableLine = mandatoryLastLineNotInterpretable;
    if (optionalReasonForFailure) {
      this.reasonForFailure = optionalReasonForFailure;
    }
    console.log('Unexpected input: "' + mandatoryLastLineNotInterpretable + '"');
  }
  getCubeSize() {
    let wXh = [this.width * 100, this.height * 100];
    return wXh;
  }
  getArrowCoordinates() {
    let ARROWS = new Array();
    let allArrowCoords = this.arrows.split(",").filter((x) => x.length > 0);
    let index = 0;
    let isDoubleSided = false;
    for (let i = 0; i < allArrowCoords.length; i++) {
      isDoubleSided = false;
      let singleArrowCoords = allArrowCoords[i];
      let singleArrowCoordsFrom;
      let singleArrowCoordsTo;
      if (singleArrowCoords.match("\\d-\\d")) {
        let singleArrowCoordsSplit = singleArrowCoords.split("-");
        singleArrowCoordsFrom = singleArrowCoordsSplit[0];
        singleArrowCoordsTo = singleArrowCoordsSplit[1];
      } else {
        let singleArrowCoordsSplit = singleArrowCoords.split("+");
        singleArrowCoordsFrom = singleArrowCoordsSplit[0];
        singleArrowCoordsTo = singleArrowCoordsSplit[1];
        isDoubleSided = true;
      }
      if (singleArrowCoordsFrom === singleArrowCoordsTo) {
        this.fuckThisShitUp(singleArrowCoords, "arrow is pointing to its starting point");
        continue;
      }
      let arrowStart;
      let arrowEnd;
      if (singleArrowCoordsFrom.match("^[0-9]+$")) {
        arrowStart = this.COORDINATES[singleArrowCoordsFrom];
      } else {
        let semanticVersion = singleArrowCoordsFrom.split(".");
        let major = +semanticVersion[0];
        let minor = +semanticVersion[1];
        let c = (major - 1) * this.width + minor;
        arrowStart = this.COORDINATES[c];
      }
      if (singleArrowCoordsTo.match("^[0-9]+$")) {
        arrowEnd = this.COORDINATES[singleArrowCoordsTo];
      } else {
        let semanticVersion = singleArrowCoordsTo.split(".");
        let major = +semanticVersion[0];
        let minor = +semanticVersion[1];
        let c = (major - 1) * this.width + minor;
        arrowEnd = this.COORDINATES[c];
      }
      ARROWS[index++] = [arrowStart, arrowEnd];
      if (isDoubleSided) {
        ARROWS[index++] = [arrowEnd, arrowStart];
      }
    }
    return ARROWS;
  }
};

// src/main.ts
var RubikCubeAlgos = class extends import_obsidian.Plugin {
  async onload() {
    this.registerMarkdownCodeBlockProcessor("rubikCubePLL", (source, el, ctx) => {
      const rows = source.split("\n").filter((row) => row.length > 0);
      let pllData = new PLL();
      pllData.interpretCodeBlock(rows);
      let widthXheight = pllData.getCubeSize();
      let ARROWS = pllData.getArrowCoordinates();
      if (false === pllData.codeBlockInterpretationSuccessful) {
        el.createEl("div", { text: "--- Rubik Cube PLL pattern interpretation failed ---" });
        el.createEl("div", { text: "Faulty input:" });
        let explanationDiv = el.createEl("div");
        explanationDiv.createEl("b", { text: '"' + pllData.lastNonInterpretableLine + '"', cls: "rubik-cube-warning-text" });
        if (pllData.reasonForFailure) {
          explanationDiv.createEl("div", { text: "(reason: " + pllData.reasonForFailure + ")" });
        }
        return;
      }
      let w = widthXheight[0];
      let h = widthXheight[1];
      let mainSvg = el.createSvg("svg", { attr: { viewBox: "0 0 " + w + " " + h, width: w, height: h }, cls: "rubik-cube-pll" });
      let defs = mainSvg.createSvg("defs");
      let marker = defs.createSvg("marker", { attr: { id: "arrowhead" + pllData.arrowColor, markerWidth: "10", markerHeight: "7", refX: "9", refY: "3.5", orient: "auto" } });
      marker.createSvg("polygon", { attr: { points: "0 0, 10 3.5, 0 7", fill: pllData.arrowColor } });
      mainSvg.createSvg("rect", { attr: { fill: pllData.cubeColor }, cls: "rubik-cube-pll-rect" });
      for (let x = 100; x < w; x += 100) {
        mainSvg.createSvg("line", { attr: { x1: x, x2: x, y1: 0, y2: h }, cls: "rubik-cube-pll-line-grid" });
      }
      for (let y = 100; y < h; y += 100) {
        mainSvg.createSvg("line", { attr: { x1: 0, x2: w, y1: y, y2: y }, cls: "rubik-cube-pll-line-grid" });
      }
      for (let i = 0; i < ARROWS.length; i++) {
        let arrow = ARROWS[i];
        let arrowStartCoord = arrow[0];
        let arrowEndCoord = arrow[1];
        mainSvg.createSvg("line", {
          attr: {
            x1: arrowStartCoord[0],
            x2: arrowEndCoord[0],
            y1: arrowStartCoord[1],
            y2: arrowEndCoord[1],
            "marker-end": "url(#arrowhead" + pllData.arrowColor + ")",
            stroke: pllData.arrowColor
          },
          cls: "rubik-cube-pll-line-arrow"
        });
      }
    });
    const codeblockTemplatePLL = "```rubikCubePLL\ndimension:3,3 // width,height\ncubeColor:ff0 // yellow cube\narrowColor:08f // sky blue arrows\narrows:1-3,7+9\n```";
    this.addCommand({
      id: "wnm-add-codeblock-template-3-3-OLL",
      name: "Add Rubik Cube Template: PLL",
      editorCallback: (editor, view) => {
        editor.replaceSelection(codeblockTemplatePLL);
      }
    });
  }
  onunload() {
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL21haW4udHMiLCAic3JjL1J1YmlrQ29vcmRpbmF0ZXMudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImltcG9ydCB7IEVkaXRvciwgTWFya2Rvd25WaWV3LCBQbHVnaW59IGZyb20gJ29ic2lkaWFuJztcclxuaW1wb3J0IHsgUExMIH0gZnJvbSBcIi4vUnViaWtDb29yZGluYXRlc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUnViaWtDdWJlQWxnb3MgZXh0ZW5kcyBQbHVnaW4ge1xyXG5cclxuXHRzZXR0aW5nczogTXlQbHVnaW5TZXR0aW5ncztcclxuXHJcblx0YXN5bmMgb25sb2FkKCkge1xyXG5cdFx0XHJcblx0XHQvL2F3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7IFxyXG5cclxuXHRcdHRoaXMucmVnaXN0ZXJNYXJrZG93bkNvZGVCbG9ja1Byb2Nlc3NvcigncnViaWtDdWJlUExMJywgKHNvdXJjZTpzdHJpbmcsIGVsLCBjdHgpID0+IHtcclxuXHRcdFx0Ly9jb25zb2xlLmxvZygnPj4gcnViaWtDdWJlUExMJyk7XHJcblx0XHRcdGNvbnN0IHJvd3MgPSBzb3VyY2Uuc3BsaXQoJ1xcbicpLmZpbHRlcigocm93KSA9PiByb3cubGVuZ3RoID4gMCk7XHJcblxyXG5cdFx0XHRsZXQgcGxsRGF0YSA9IG5ldyBQTEwoKTsgXHJcblx0XHRcdHBsbERhdGEuaW50ZXJwcmV0Q29kZUJsb2NrKHJvd3MpOyBcclxuXHRcdFx0bGV0IHdpZHRoWGhlaWdodCA9IHBsbERhdGEuZ2V0Q3ViZVNpemUoKTtcclxuXHRcdFx0bGV0IEFSUk9XUyA9IHBsbERhdGEuZ2V0QXJyb3dDb29yZGluYXRlcygpO1xyXG5cclxuXHRcdFx0aWYgKGZhbHNlID09PSBwbGxEYXRhLmNvZGVCbG9ja0ludGVycHJldGF0aW9uU3VjY2Vzc2Z1bCl7XHJcblx0XHRcdFx0ZWwuY3JlYXRlRWwoJ2RpdicsIHsgdGV4dDogXCItLS0gUnViaWsgQ3ViZSBQTEwgcGF0dGVybiBpbnRlcnByZXRhdGlvbiBmYWlsZWQgLS0tXCIgfSk7XHJcblx0XHRcdFx0ZWwuY3JlYXRlRWwoJ2RpdicsIHsgdGV4dDogJ0ZhdWx0eSBpbnB1dDonIH0pO1xyXG5cdFx0XHRcdGxldCBleHBsYW5hdGlvbkRpdiA9IGVsLmNyZWF0ZUVsKCdkaXYnKTtcclxuXHRcdFx0XHRleHBsYW5hdGlvbkRpdi5jcmVhdGVFbCgnYicsIHsgdGV4dDogJ1wiJytwbGxEYXRhLmxhc3ROb25JbnRlcnByZXRhYmxlTGluZSsnXCInLCBjbHM6J3J1YmlrLWN1YmUtd2FybmluZy10ZXh0JyAgfSk7XHJcblx0XHRcdFx0aWYgKHBsbERhdGEucmVhc29uRm9yRmFpbHVyZSkge1xyXG5cdFx0XHRcdFx0ZXhwbGFuYXRpb25EaXYuY3JlYXRlRWwoJ2RpdicsIHsgdGV4dDogJyhyZWFzb246ICcrIHBsbERhdGEucmVhc29uRm9yRmFpbHVyZSArJyknIH0pO1xyXG5cdFx0XHRcdH1cdFx0XHRcdFxyXG5cdFx0XHRcdHJldHVybjsgXHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdGxldCB3ID0gd2lkdGhYaGVpZ2h0WzBdOyBcclxuXHRcdFx0bGV0IGggPSB3aWR0aFhoZWlnaHRbMV07IFxyXG5cdFx0XHQvL2NvbnNvbGUubG9nKCctLSB3OicrdysnLCBoOicraCk7ICAgXHJcblxyXG5cclxuXHRcdFx0bGV0IG1haW5TdmcgPSBlbC5jcmVhdGVTdmcoJ3N2ZycsIHsgYXR0cjogeyB2aWV3Qm94OicwIDAgJyt3KycgJytoLCB3aWR0aDp3LCBoZWlnaHQ6aCB9LCBjbHM6IFwicnViaWstY3ViZS1wbGxcIiB9KTtcclxuXHRcdFx0XHJcblx0XHRcdGxldCBkZWZzID0gbWFpblN2Zy5jcmVhdGVTdmcoJ2RlZnMnKTtcclxuXHRcdFx0bGV0IG1hcmtlciA9IGRlZnMuY3JlYXRlU3ZnKCdtYXJrZXInLCB7IGF0dHI6IHtpZDpcImFycm93aGVhZFwiK3BsbERhdGEuYXJyb3dDb2xvciwgbWFya2VyV2lkdGg6XCIxMFwiLCBtYXJrZXJIZWlnaHQ6XCI3XCIsIHJlZlg6XCI5XCIsIHJlZlk6XCIzLjVcIiwgb3JpZW50OlwiYXV0b1wifX0pO1xyXG5cdFx0XHRtYXJrZXIuY3JlYXRlU3ZnKCdwb2x5Z29uJywgeyBhdHRyOiB7cG9pbnRzOlwiMCAwLCAxMCAzLjUsIDAgN1wiICwgZmlsbDpwbGxEYXRhLmFycm93Q29sb3J9fSk7XHJcblx0XHRcdFxyXG5cdFx0XHRcclxuXHRcdFx0LyogWWVsbG93IGJhc2UgcmVjdCAqL1xyXG5cdFx0XHRtYWluU3ZnLmNyZWF0ZVN2ZygncmVjdCcsIHsgYXR0cjogeyBmaWxsOnBsbERhdGEuY3ViZUNvbG9yIH0sIGNsczogXCJydWJpay1jdWJlLXBsbC1yZWN0XCIgfSk7IFxyXG5cdFx0XHRcclxuXHRcdFx0LypcclxuXHRcdFx0ICogQmFja2dyb3VuZCBncmlkOyBzdGF0aWMsIHVucmVzcG9uc2l2ZSwgYmxhY2sgcmVjdGFuZ3VsYXIgbGluZXNcclxuXHRcdFx0ICovXHJcblx0XHRcdC8qIFZlcnRpY2FsIGxpbmVzICovXHJcblx0XHRcdGZvciAobGV0IHg6bnVtYmVyID0gMTAwOyB4IDwgdzsgeCs9MTAwKSB7XHJcblx0XHRcdFx0bWFpblN2Zy5jcmVhdGVTdmcoJ2xpbmUnLCB7IGF0dHI6IHsgeDE6eCwgeDI6eCwgeTE6MCwgeTI6aCB9LCBjbHM6IFwicnViaWstY3ViZS1wbGwtbGluZS1ncmlkXCIgfSk7XHJcblx0XHRcdH1cclxuXHRcdFx0LyogSG9yaXpvbnRhbCBsaW5lcyAqLyBcclxuXHRcdFx0Zm9yIChsZXQgeTpudW1iZXIgPSAxMDA7IHkgPCBoOyB5Kz0xMDApIHtcclxuXHRcdFx0XHRtYWluU3ZnLmNyZWF0ZVN2ZygnbGluZScsIHsgYXR0cjogeyB4MTowLCB4Mjp3LCB5MTp5LCB5Mjp5IH0sIGNsczogXCJydWJpay1jdWJlLXBsbC1saW5lLWdyaWRcIiB9KTtcclxuXHRcdFx0fVxyXG5cclxuXHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IEFSUk9XUy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGxldCBhcnJvdyA9IEFSUk9XU1tpXTtcclxuXHRcdFx0XHRsZXQgYXJyb3dTdGFydENvb3JkID0gYXJyb3dbMF07XHJcblx0XHRcdFx0bGV0IGFycm93RW5kQ29vcmQgPSBhcnJvd1sxXTtcclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKFwiQXJyb3cgZ29lcyBmcm9tIFwiK2Fycm93U3RhcnRDb29yZCtcIiB0byBcIithcnJvd0VuZENvb3JkKTtcclxuXHRcdFx0XHRtYWluU3ZnLmNyZWF0ZVN2ZygnbGluZScsIHsgYXR0cjogeyB4MTphcnJvd1N0YXJ0Q29vcmRbMF0sIHgyOmFycm93RW5kQ29vcmRbMF0sIHkxOmFycm93U3RhcnRDb29yZFsxXSwgeTI6YXJyb3dFbmRDb29yZFsxXSxcclxuXHRcdFx0XHRcdFx0XHQnbWFya2VyLWVuZCc6J3VybCgjYXJyb3doZWFkJytwbGxEYXRhLmFycm93Q29sb3IrJyknLCBzdHJva2U6cGxsRGF0YS5hcnJvd0NvbG9yLCAgfSxcclxuXHRcdFx0XHRjbHM6IFwicnViaWstY3ViZS1wbGwtbGluZS1hcnJvd1wiIH0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRcclxuXHRcdFx0Ly9jb25zb2xlLmxvZygnPDwgcnViaWtDdWJlUExMJyk7XHRcdFxyXG5cdFx0fSk7XHJcblx0XHRcclxuXHRcdGNvbnN0IGNvZGVibG9ja1RlbXBsYXRlUExMOnN0cmluZyA9IFxyXG4nYGBgcnViaWtDdWJlUExMXFxuJytcclxuJ2RpbWVuc2lvbjozLDMgLy8gd2lkdGgsaGVpZ2h0XFxuJytcclxuJ2N1YmVDb2xvcjpmZjAgLy8geWVsbG93IGN1YmVcXG4nK1xyXG4nYXJyb3dDb2xvcjowOGYgLy8gc2t5IGJsdWUgYXJyb3dzXFxuJytcclxuJ2Fycm93czoxLTMsNys5XFxuJytcclxuJ2BgYCc7XHJcblxyXG5cdFx0Ly8gQWRkIFJ1YmlrIEN1YmUgY29kZWJsb2NrIHRlbXBsYXRlOiBcclxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XHJcblx0XHRcdGlkOiAnd25tLWFkZC1jb2RlYmxvY2stdGVtcGxhdGUtMy0zLU9MTCcsXHRcclxuXHRcdFx0bmFtZTogJ0FkZCBSdWJpayBDdWJlIFRlbXBsYXRlOiBQTEwnLFxyXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcclxuXHRcdFx0XHRlZGl0b3IucmVwbGFjZVNlbGVjdGlvbihjb2RlYmxvY2tUZW1wbGF0ZVBMTCk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHJcblx0XHQvLyBXaGVuIHJlZ2lzdGVyaW5nIGludGVydmFscywgdGhpcyBmdW5jdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgY2xlYXIgdGhlIGludGVydmFsIHdoZW4gdGhlIHBsdWdpbiBpcyBkaXNhYmxlZC5cclxuXHRcdC8vdGhpcy5yZWdpc3RlckludGVydmFsKHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiBjb25zb2xlLmxvZygnc2V0SW50ZXJ2YWwnKSwgNSAqIDYwICogMTAwMCkpO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHRvbnVubG9hZCgpIHtcclxuXHR9XHJcblxyXG59XHJcbiIsICJjb25zdCBERUZBVUxUID0ge1xyXG5cdFdJRFRIOiAzLCAvKiBkZWZhdWx0IHJ1YmlrIGN1YmUgd2lkdGggKi9cclxuXHRIRUlHSFQ6IDMsIC8qIGRlZmF1bHQgcnViaWsgY3ViZSBoZWlnaHQgKi9cclxuXHRDVUJFX0NPTE9SOiBcIiNmZjBcIiwgLyogeWVsbG93IGZvciBjdWJlICovXHJcblx0QVJST1dfQ09MT1I6IFwiIzA4ZlwiLCAvKiBza3kgYmx1ZSBmb3IgYXJyb3dzICovXHJcbn0gYXMgY29uc3Q7IFxyXG5cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgUExMIHtcclxuXHRDT09SRElOQVRFUztcclxuXHR3aWR0aDpudW1iZXI7XHJcblx0aGVpZ2h0Om51bWJlcjtcclxuXHRjdWJlQ29sb3I6c3RyaW5nO1xyXG5cdGFycm93Q29sb3I6c3RyaW5nO1xyXG5cdGFycm93czpzdHJpbmc7XHJcblx0Y29kZUJsb2NrSW50ZXJwcmV0YXRpb25TdWNjZXNzZnVsOmJvb2xlYW47XHJcblx0bGFzdE5vbkludGVycHJldGFibGVMaW5lOnN0cmluZzsgXHJcblx0cmVhc29uRm9yRmFpbHVyZTpzdHJpbmc7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cdFx0dGhpcy5DT09SRElOQVRFUyA9IG5ldyBBcnJheSgpXHJcblx0XHR0aGlzLndpZHRoID0gREVGQVVMVC5XSURUSDtcclxuXHRcdHRoaXMuaGVpZ2h0ID0gREVGQVVMVC5IRUlHSFQ7XHJcblx0XHR0aGlzLmN1YmVDb2xvciA9IERFRkFVTFQuQ1VCRV9DT0xPUjtcclxuXHRcdHRoaXMuYXJyb3dDb2xvciA9IERFRkFVTFQuQVJST1dfQ09MT1I7XHJcblx0XHR0aGlzLmFycm93cyA9IFwiXCI7XHJcblx0XHR0aGlzLmNvZGVCbG9ja0ludGVycHJldGF0aW9uU3VjY2Vzc2Z1bD10cnVlO1xyXG5cdH1cclxuXHRwcml2YXRlIHNldERpbWVuc2lvbih3Om51bWJlcixoOm51bWJlcik6dm9pZCB7XHJcblx0XHR0aGlzLndpZHRoPXc7XHJcblx0XHR0aGlzLmhlaWdodD1oO1xyXG5cdFx0Ly9jb25zb2xlLmxvZyhcIm5ldyBkaW1lbnNpb25zOiBcIit3K1wiLFwiK2gpO1xyXG5cdH1cclxuXHRwcml2YXRlIHNldEN1YmVDb2xvcihzOnN0cmluZyk6dm9pZCB7XHJcblx0XHR0aGlzLmN1YmVDb2xvciA9ICcjJytzO1xyXG5cdFx0Ly9jb25zb2xlLmxvZyhcIm5ldyBjdWJlIGNvbG9yOiAnXCIrcytcIidcIik7XHJcblx0fVxyXG5cdHByaXZhdGUgc2V0QXJyb3dDb2xvcihzOnN0cmluZyk6dm9pZCB7XHJcblx0XHR0aGlzLmFycm93Q29sb3IgPSAnIycrcztcclxuXHRcdC8vY29uc29sZS5sb2coXCJuZXcgYXJyb3cgY29sb3I6ICdcIitzK1wiJ1wiKTtcclxuXHR9XHJcblx0cHJpdmF0ZSBzZXRBcnJvd3MoczpzdHJpbmcpOnZvaWQge1xyXG5cdFx0dGhpcy5hcnJvd3MgPSBzO1xyXG5cdFx0Ly9jb25zb2xlLmxvZyhcIm5ldyBhcnJvd3M6ICdcIitzK1wiJ1wiKTtcclxuXHR9XHJcblx0dG9TdHJpbmcoKTpzdHJpbmcge1xyXG5cdFx0cmV0dXJuIFwicGxsW2N1YmVDbHInXCIrdGhpcy5jdWJlQ29sb3IrXCInLGFycm93Q29sb3InXCIrdGhpcy5hcnJvd0NvbG9yK1wiJyxhcnJvd3MnXCIrdGhpcy5hcnJvd3MrXCInXVwiXHJcblx0fVxyXG5cdGludGVycHJldENvZGVCbG9jayhyb3dzOnN0cmluZ1tdKTp2b2lkIHtcclxuXHRcdGlmIChyb3dzLmxlbmd0aCA9PT0wKXtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZnVja1RoaXNTaGl0VXAoXCJbbm8gaW5wdXRdXCIsXCJhdCBsZWFzdCAxIHBhcmFtZXRlciBuZWVkZWQ6ICdkaW1lbnNpb24vY3ViZUNvbG9yL2Fycm93Q29sb3IvYXJyb3dzJ1wiKTtcclxuXHRcdH1cclxuXHRcdC8vIGNvbnNvbGUubG9nKCdwbGwgYmVmb3JlOiAnK3RoaXMudG9TdHJpbmcoKSk7XHRcdFxyXG5cdFx0Zm9yIChsZXQgciA9IDA7IHIgPCByb3dzLmxlbmd0aDsgcisrKSB7XHJcblx0XHRcdGxldCByb3cgPSByb3dzW3JdO1xyXG5cdFx0XHRpZiAocm93Lm1hdGNoKCdkaW1lbnNpb246XFxcXGQrLFxcXFxkKyggLy8uKik/JykpIHtcclxuXHRcdFx0XHRsZXQgd1hoID0gcm93LnNwbGl0KCcgJylbMF0udHJpbSgpLnJlcGxhY2UoJ2RpbWVuc2lvbjonLCcnKTtcclxuXHRcdFx0XHRsZXQgd1hoU3BsaXQgPSB3WGguc3BsaXQoJywnKTtcclxuXHRcdFx0XHRsZXQgdz0gd1hoU3BsaXRbMF07XHJcblx0XHRcdFx0bGV0IGg9IHdYaFNwbGl0WzFdO1xyXG5cdFx0XHRcdGlmICh3PDJ8fGg8Mnx8dz4xMHx8aD4xMCl7XHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5mdWNrVGhpc1NoaXRVcChyb3csJ2ludmFsaWQgZGltZW5zaW9ucyAtIGV4cGVjdGVkOiAyIDwgd2lkdGgvaGVpZ2h0IDwgMTAnKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy5zZXREaW1lbnNpb24odyxoKTtcclxuXHRcdFx0fSBlbHNlIGlmIChyb3cubWF0Y2goJ2N1YmVDb2xvcjooW2EtZjAtOV17M30pezEsMn0oIC8vLiopPycpKSB7XHJcblx0XHRcdFx0bGV0IG5ld0N1YkNsciA9IHJvdy5zcGxpdCgnICcpWzBdLnRyaW0oKS5yZXBsYWNlKCdjdWJlQ29sb3I6JywnJyk7XHJcblx0XHRcdFx0dGhpcy5zZXRDdWJlQ29sb3IobmV3Q3ViQ2xyKTtcclxuXHRcdFx0fSBlbHNlIGlmIChyb3cubWF0Y2goJ2Fycm93Q29sb3I6KFthLWYwLTldezN9KXsxLDJ9KCAvLy4qKT8nKSkge1xyXG5cdFx0XHRcdGxldCBuZXdBcm9DbHIgPSByb3cuc3BsaXQoJyAnKVswXS50cmltKCkucmVwbGFjZSgnYXJyb3dDb2xvcjonLCcnKVxyXG5cdFx0XHRcdHRoaXMuc2V0QXJyb3dDb2xvcihuZXdBcm9DbHIpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHJvdy5tYXRjaCgnYXJyb3dzOlxcXFxkKyhcXFxcLlxcXFxkKyk/KC18XFxcXCspXFxcXGQrKFxcXFwuXFxcXGQrKT8oLFxcXFxkKyhcXFxcLlxcXFxkKyk/KC18XFxcXCspXFxcXGQrKFxcXFwuXFxcXGQrKT8pKiggLy8uKik/JykpIHtcclxuXHRcdFx0XHRsZXQgbmV3QXJyb3dzID0gcm93LnNwbGl0KCcgJylbMF0udHJpbSgpLnJlcGxhY2UoJ2Fycm93czonLCcnKVxyXG5cdFx0XHRcdHRoaXMuc2V0QXJyb3dzKG5ld0Fycm93cyk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnVja1RoaXNTaGl0VXAocm93KTtcclxuXHRcdFx0fVxyXG5cdFx0fVx0XHJcblx0XHR0aGlzLmNhbGN1bGF0ZUNvb3JkaW5hdGVzKCk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGNhbGN1bGF0ZUNvb3JkaW5hdGVzKCl7XHJcblx0XHR0aGlzLkNPT1JESU5BVEVTWzBdID0gW107XHJcblx0XHRsZXQgaW5kZXg6bnVtYmVyPTE7XHJcblx0XHQvKiByZXZlcnNlIGxvb3Agb3JkZXIgdG8gZ2l2ZSB4IGNvb3JkaW5hdGVzIG1vcmUgcHJpb3JpdHkgKi9cclxuXHRcdGZvciAobGV0IGggPSAwOyBoIDwgdGhpcy5oZWlnaHQ7IGgrKykge1xyXG5cdFx0XHRmb3IgKGxldCB3ID0gMDsgdyA8IHRoaXMud2lkdGg7IHcrKykge1xyXG5cdFx0XHRcdHRoaXMuQ09PUkRJTkFURVNbaW5kZXgrK10gPSBbdyoxMDAgKyA1MCwgaCoxMDAgKyA1MF07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0cHJpdmF0ZSBmdWNrVGhpc1NoaXRVcChtYW5kYXRvcnlMYXN0TGluZU5vdEludGVycHJldGFibGU6c3RyaW5nLCBvcHRpb25hbFJlYXNvbkZvckZhaWx1cmU6c3RyaW5nKXtcclxuXHRcdHRoaXMuY29kZUJsb2NrSW50ZXJwcmV0YXRpb25TdWNjZXNzZnVsPWZhbHNlO1xyXG5cdFx0dGhpcy5sYXN0Tm9uSW50ZXJwcmV0YWJsZUxpbmU9bWFuZGF0b3J5TGFzdExpbmVOb3RJbnRlcnByZXRhYmxlO1xyXG5cdFx0aWYgKG9wdGlvbmFsUmVhc29uRm9yRmFpbHVyZSkge1xyXG5cdFx0XHR0aGlzLnJlYXNvbkZvckZhaWx1cmU9b3B0aW9uYWxSZWFzb25Gb3JGYWlsdXJlO1xyXG5cdFx0fVxyXG5cdFx0Y29uc29sZS5sb2coJ1VuZXhwZWN0ZWQgaW5wdXQ6IFwiJyttYW5kYXRvcnlMYXN0TGluZU5vdEludGVycHJldGFibGUrJ1wiJyk7XHJcblx0fVxyXG5cdGdldEN1YmVTaXplKCl7XHJcblx0XHRsZXQgd1hoID0gW3RoaXMud2lkdGgqMTAwLCB0aGlzLmhlaWdodCoxMDBdO1xyXG5cdFx0cmV0dXJuIHdYaDtcclxuXHR9XHJcblx0Z2V0QXJyb3dDb29yZGluYXRlcygpIHtcclxuXHRcdC8vY29uc29sZS5sb2coJz4+IGdldEFycm93Q29vcmRpbmF0ZXMsICcgKyB0aGlzLkNPT1JESU5BVEVTKTtcclxuXHRcdGxldCBBUlJPV1MgPSBuZXcgQXJyYXkoKTtcclxuXHRcdGxldCBhbGxBcnJvd0Nvb3JkcyA9IHRoaXMuYXJyb3dzLnNwbGl0KCcsJykuZmlsdGVyKCh4KSA9PiB4Lmxlbmd0aCA+IDApO1xyXG5cdFx0bGV0IGluZGV4Om51bWJlciA9IDA7XHJcblx0XHQvL2NvbnNvbGUubG9nKFwiQXJyb3dzIHRvIGludGVycHJldDogXCIrYWxsQXJyb3dDb29yZHMpO1xyXG5cdFx0bGV0IGlzRG91YmxlU2lkZWQ6Ym9vbGVhbiA9IGZhbHNlO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhbGxBcnJvd0Nvb3Jkcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpc0RvdWJsZVNpZGVkID0gZmFsc2U7XHJcblx0XHRcdGxldCBzaW5nbGVBcnJvd0Nvb3JkczpzdHJpbmcgPSBhbGxBcnJvd0Nvb3Jkc1tpXTtcclxuXHRcdFx0bGV0IHNpbmdsZUFycm93Q29vcmRzRnJvbTpzdHJpbmc7IFxyXG5cdFx0XHRsZXQgc2luZ2xlQXJyb3dDb29yZHNUbzpzdHJpbmc7XHJcblx0XHRcdFxyXG5cdFx0XHRpZiAoc2luZ2xlQXJyb3dDb29yZHMubWF0Y2goJ1xcXFxkLVxcXFxkJykpIHtcclxuXHRcdFx0XHRsZXQgc2luZ2xlQXJyb3dDb29yZHNTcGxpdCA9IHNpbmdsZUFycm93Q29vcmRzLnNwbGl0KCctJyk7XHJcblx0XHRcdFx0c2luZ2xlQXJyb3dDb29yZHNGcm9tID0gc2luZ2xlQXJyb3dDb29yZHNTcGxpdFswXTtcclxuXHRcdFx0XHRzaW5nbGVBcnJvd0Nvb3Jkc1RvID0gc2luZ2xlQXJyb3dDb29yZHNTcGxpdFsxXTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgc2luZ2xlQXJyb3dDb29yZHNTcGxpdCA9IHNpbmdsZUFycm93Q29vcmRzLnNwbGl0KCcrJyk7XHJcblx0XHRcdFx0c2luZ2xlQXJyb3dDb29yZHNGcm9tID0gc2luZ2xlQXJyb3dDb29yZHNTcGxpdFswXTtcclxuXHRcdFx0XHRzaW5nbGVBcnJvd0Nvb3Jkc1RvID0gc2luZ2xlQXJyb3dDb29yZHNTcGxpdFsxXTtcclxuXHRcdFx0XHRpc0RvdWJsZVNpZGVkID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHNpbmdsZUFycm93Q29vcmRzRnJvbT09PXNpbmdsZUFycm93Q29vcmRzVG8pe1xyXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiU2tpcCBhcnJvdyBwb2ludGluZyB0byBpdHNlbGY6IFwiK3NpbmdsZUFycm93Q29vcmRzRnJvbSk7XHJcblx0XHRcdFx0dGhpcy5mdWNrVGhpc1NoaXRVcChzaW5nbGVBcnJvd0Nvb3JkcywnYXJyb3cgaXMgcG9pbnRpbmcgdG8gaXRzIHN0YXJ0aW5nIHBvaW50Jyk7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vY29uc29sZS5sb2coXCItLSBBcnJvdyBnb2VzIGZyb20gJ1wiK3NpbmdsZUFycm93Q29vcmRzRnJvbStcIicgdG8gJ1wiK3NpbmdsZUFycm93Q29vcmRzVG8rXCInXCIpO1xyXG5cdFx0XHRcclxuXHRcdFx0bGV0IGFycm93U3RhcnQ7XHJcblx0XHRcdGxldCBhcnJvd0VuZDtcclxuXHRcdFx0XHJcblx0XHRcdGlmIChzaW5nbGVBcnJvd0Nvb3Jkc0Zyb20ubWF0Y2goJ15bMC05XSskJykpe1xyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJy0tIGQ6ICcgKyBzaW5nbGVBcnJvd0Nvb3Jkc0Zyb20pO1xyXG5cdFx0XHRcdGFycm93U3RhcnQgPSB0aGlzLkNPT1JESU5BVEVTW3NpbmdsZUFycm93Q29vcmRzRnJvbV07XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IHNlbWFudGljVmVyc2lvbiA9IHNpbmdsZUFycm93Q29vcmRzRnJvbS5zcGxpdCgnLicpO1xyXG5cdFx0XHRcdGxldCBtYWpvcjpudW1iZXIgPSArc2VtYW50aWNWZXJzaW9uWzBdO1xyXG5cdFx0XHRcdGxldCBtaW5vcjpudW1iZXIgPSArc2VtYW50aWNWZXJzaW9uWzFdO1xyXG5cdFx0XHRcdGxldCBjOm51bWJlciA9IChtYWpvci0xKSp0aGlzLndpZHRoICsgbWlub3I7XHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnLS0gYzogJyArIGMpO1xyXG5cdFx0XHRcdGFycm93U3RhcnQgPSB0aGlzLkNPT1JESU5BVEVTW2NdO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRpZiAoc2luZ2xlQXJyb3dDb29yZHNUby5tYXRjaCgnXlswLTldKyQnKSl7XHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnLS0gZDogJyArIHNpbmdsZUFycm93Q29vcmRzVG8pO1xyXG5cdFx0XHRcdGFycm93RW5kID0gdGhpcy5DT09SRElOQVRFU1tzaW5nbGVBcnJvd0Nvb3Jkc1RvXTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgc2VtYW50aWNWZXJzaW9uID0gc2luZ2xlQXJyb3dDb29yZHNUby5zcGxpdCgnLicpO1xyXG5cdFx0XHRcdGxldCBtYWpvcjpudW1iZXIgPSArc2VtYW50aWNWZXJzaW9uWzBdO1xyXG5cdFx0XHRcdGxldCBtaW5vcjpudW1iZXIgPSArc2VtYW50aWNWZXJzaW9uWzFdO1xyXG5cdFx0XHRcdGxldCBjOm51bWJlciA9IChtYWpvci0xKSp0aGlzLndpZHRoICsgbWlub3I7XHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnLS0gYzogJyArIGMpO1xyXG5cdFx0XHRcdGFycm93RW5kID0gdGhpcy5DT09SRElOQVRFU1tjXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0XHJcblx0XHRcdEFSUk9XU1tpbmRleCsrXSA9IFsgYXJyb3dTdGFydCwgYXJyb3dFbmQgXTtcclxuXHRcdFx0XHJcblx0XHRcdGlmIChpc0RvdWJsZVNpZGVkKSB7IC8vIGFkZCByZXZlcnNlIGNvcHlcclxuXHRcdFx0XHRBUlJPV1NbaW5kZXgrK10gPSBbIGFycm93RW5kLCBhcnJvd1N0YXJ0IF07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdC8vY29uc29sZS5sb2coJzw8IGdldEFycm93Q29vcmRpbmF0ZXMsICcgKyBBUlJPV1MpO1xyXG5cdFx0cmV0dXJuIEFSUk9XUztcclxuXHR9XHJcbn07Il0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHNCQUE0Qzs7O0FDQTVDLElBQU0sVUFBVTtBQUFBLEVBQ2YsT0FBTztBQUFBO0FBQUEsRUFDUCxRQUFRO0FBQUE7QUFBQSxFQUNSLFlBQVk7QUFBQTtBQUFBLEVBQ1osYUFBYTtBQUFBO0FBQ2Q7QUFJTyxJQUFNLE1BQU4sTUFBVTtBQUFBLEVBV2hCLGNBQWM7QUFDYixTQUFLLGNBQWMsSUFBSSxNQUFNO0FBQzdCLFNBQUssUUFBUSxRQUFRO0FBQ3JCLFNBQUssU0FBUyxRQUFRO0FBQ3RCLFNBQUssWUFBWSxRQUFRO0FBQ3pCLFNBQUssYUFBYSxRQUFRO0FBQzFCLFNBQUssU0FBUztBQUNkLFNBQUssb0NBQWtDO0FBQUEsRUFDeEM7QUFBQSxFQUNRLGFBQWEsR0FBUyxHQUFlO0FBQzVDLFNBQUssUUFBTTtBQUNYLFNBQUssU0FBTztBQUFBLEVBRWI7QUFBQSxFQUNRLGFBQWEsR0FBZTtBQUNuQyxTQUFLLFlBQVksTUFBSTtBQUFBLEVBRXRCO0FBQUEsRUFDUSxjQUFjLEdBQWU7QUFDcEMsU0FBSyxhQUFhLE1BQUk7QUFBQSxFQUV2QjtBQUFBLEVBQ1EsVUFBVSxHQUFlO0FBQ2hDLFNBQUssU0FBUztBQUFBLEVBRWY7QUFBQSxFQUNBLFdBQWtCO0FBQ2pCLFdBQU8saUJBQWUsS0FBSyxZQUFVLGtCQUFnQixLQUFLLGFBQVcsY0FBWSxLQUFLLFNBQU87QUFBQSxFQUM5RjtBQUFBLEVBQ0EsbUJBQW1CLE1BQW9CO0FBQ3RDLFFBQUksS0FBSyxXQUFVLEdBQUU7QUFDcEIsYUFBTyxLQUFLLGVBQWUsY0FBYSxz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
